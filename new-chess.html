<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the chess game */
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap to zoom on mobile */
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 70vh;
            max-height: 70vh;
            border: 2px solid #4a5568; /* gray-700 */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .square.light {
            background-color: #f0e2d1; /* A soft beige */
        }

        .square.dark {
            background-color: #8a6d5b; /* A warm brown */
        }

        .piece {
            font-size: clamp(20px, 8vw, 50px); /* Responsive font size for pieces */
            cursor: pointer;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease-in-out;
        }
        
        .piece.white { color: #ffffff; }
        .piece.black { color: #2d3748; } /* gray-800 */

        .selected {
            background-color: #f6e05e !important; /* yellow-300 */
        }

        .valid-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35%;
            height: 35%;
            background-color: rgba(45, 55, 72, 0.5); /* gray-700 with opacity */
            border-radius: 50%;
            pointer-events: none; /* Allows clicks to pass through to the square */
        }
        
        .in-check {
             background-color: #e53e3e !important; /* red-600 */
        }
    </style>
</head>
<body class="bg-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto">
        <!-- Header and Status Display -->
        <div class="bg-white rounded-lg shadow-md p-4 mb-4 flex justify-between items-center">
            <div>
                <h1 class="text-xl sm:text-2xl font-bold text-gray-800">Chess Game</h1>
                <p id="status" class="text-gray-600 font-medium">White's Turn</p>
            </div>
            <button id="newGameBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-300">
                New Game
            </button>
        </div>

        <!-- Chess Board -->
        <div id="board" class="board"></div>

        <!-- Modal for Game Over -->
        <div id="gameOverModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center">
            <div class="bg-white rounded-lg p-8 shadow-xl text-center">
                <h2 id="modalMessage" class="text-2xl font-bold mb-4"></h2>
                <button id="modalNewGameBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-300">
                    Play Again
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('board');
            const statusElement = document.getElementById('status');
            const newGameBtn = document.getElementById('newGameBtn');
            const gameOverModal = document.getElementById('gameOverModal');
            const modalMessage = document.getElementById('modalMessage');
            const modalNewGameBtn = document.getElementById('modalNewGameBtn');

            // --- Piece Unicode Representation ---
            // Using Font Awesome classes instead for better visuals
            const pieceClasses = {
                'K': 'fa-chess-king', 'Q': 'fa-chess-queen', 'R': 'fa-chess-rook',
                'B': 'fa-chess-bishop', 'N': 'fa-chess-knight', 'P': 'fa-chess-pawn'
            };

            // --- Game State Variables ---
            let board = [];
            let currentPlayer = 'white';
            let selectedPiece = null; // { row, col, piece }
            let validMoves = [];
            let kingPositions = { white: null, black: null };
            let isGameOver = false;

            // --- Game Initialization ---
            function initGame() {
                // Standard chess starting position
                board = [
                    ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
                    ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
                    ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
                ];

                currentPlayer = 'white';
                selectedPiece = null;
                validMoves = [];
                isGameOver = false;
                findKings();
                renderBoard();
                updateStatus();
                gameOverModal.classList.add('hidden');
            }

            // --- Board Rendering ---
            function renderBoard() {
                boardElement.innerHTML = '';
                // Clear existing check highlights
                document.querySelectorAll('.in-check').forEach(el => el.classList.remove('in-check'));

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.dataset.row = r;
                        square.dataset.col = c;
                        square.classList.add('square');
                        square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');

                        const pieceStr = board[r][c];
                        if (pieceStr) {
                            const pieceColor = pieceStr[0] === 'w' ? 'white' : 'black';
                            const pieceType = pieceStr[1];
                            const pieceElement = document.createElement('i');
                            pieceElement.classList.add('fas', pieceClasses[pieceType], 'piece', pieceColor);
                            square.appendChild(pieceElement);
                        }
                        
                        // Highlight king if in check
                        if (kingPositions.white && kingPositions.white.row === r && kingPositions.white.col === c && isKingInCheck('white')) {
                            square.classList.add('in-check');
                        }
                        if (kingPositions.black && kingPositions.black.row === r && kingPositions.black.col === c && isKingInCheck('black')) {
                            square.classList.add('in-check');
                        }

                        boardElement.appendChild(square);
                    }
                }
                addSquareEventListeners();
            }
            
             // --- Find King Positions ---
            function findKings() {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === 'wK') kingPositions.white = { row: r, col: c };
                        if (board[r][c] === 'bK') kingPositions.black = { row: r, col: c };
                    }
                }
            }

            // --- Event Handling ---
            function addSquareEventListeners() {
                const squares = document.querySelectorAll('.square');
                squares.forEach(square => {
                    square.addEventListener('click', onSquareClick);
                });
            }

            function onSquareClick(event) {
                if (isGameOver) return;

                const square = event.currentTarget;
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                const piece = board[row][col];

                if (selectedPiece) {
                    // Check if the clicked square is a valid move
                    const isMoveValid = validMoves.some(move => move.row === row && move.col === col);
                    if (isMoveValid) {
                        movePiece(selectedPiece.row, selectedPiece.col, row, col);
                    } else {
                        // Deselect or select another piece
                        clearHighlights();
                        selectedPiece = null;
                        // If clicking another piece of the same color, select it
                        if (piece && piece[0] === currentPlayer[0]) {
                            selectPiece(row, col, piece);
                        }
                    }
                } else if (piece && piece[0] === currentPlayer[0]) {
                    // No piece selected, so select this one
                    selectPiece(row, col, piece);
                }
            }
            
            function selectPiece(row, col, piece) {
                clearHighlights();
                selectedPiece = { row, col, piece };
                validMoves = getValidMoves(row, col, piece);
                
                // Highlight selected piece and its valid moves
                document.querySelector(`[data-row='${row}'][data-col='${col}']`).classList.add('selected');
                validMoves.forEach(move => {
                    document.querySelector(`[data-row='${move.row}'][data-col='${move.col}']`).classList.add('valid-move');
                });
            }
            
            function clearHighlights() {
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll('.valid-move').forEach(el => el.classList.remove('valid-move'));
            }

            // --- Move Execution ---
            function movePiece(fromRow, fromCol, toRow, toCol) {
                board[toRow][toCol] = board[fromRow][fromCol];
                board[fromRow][fromCol] = null;
                
                // Update king position if moved
                if (selectedPiece.piece === 'wK') kingPositions.white = { row: toRow, col: toCol };
                if (selectedPiece.piece === 'bK') kingPositions.black = { row: toRow, col: toCol };

                // Handle pawn promotion
                const piece = board[toRow][toCol];
                if (piece[1] === 'P' && (toRow === 0 || toRow === 7)) {
                    board[toRow][toCol] = piece[0] + 'Q'; // Promote to Queen by default
                }
                
                // Switch turns and update state
                currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                selectedPiece = null;
                validMoves = [];
                clearHighlights();
                renderBoard();
                updateStatus();
                checkGameState();
            }

            // --- Game Logic: Valid Moves ---
            function getValidMoves(row, col, piece) {
                const moves = [];
                const color = piece[0];
                const type = piece[1];

                switch (type) {
                    case 'P': moves.push(...getPawnMoves(row, col, color)); break;
                    case 'R': moves.push(...getRookMoves(row, col, color)); break;
                    case 'N': moves.push(...getKnightMoves(row, col, color)); break;
                    case 'B': moves.push(...getBishopMoves(row, col, color)); break;
                    case 'Q': moves.push(...getQueenMoves(row, col, color)); break;
                    case 'K': moves.push(...getKingMoves(row, col, color)); break;
                }
                
                // Filter out moves that would leave the king in check
                return moves.filter(move => !moveLeavesKingInCheck(row, col, move.row, move.col, color));
            }
            
            function getPawnMoves(r, c, color) {
                const moves = [];
                const dir = color === 'w' ? -1 : 1;
                const startRow = color === 'w' ? 6 : 1;

                // 1 step forward
                if (isValid(r + dir, c) && !board[r + dir][c]) {
                    moves.push({ row: r + dir, col: c });
                    // 2 steps forward from start
                    if (r === startRow && isValid(r + 2 * dir, c) && !board[r + 2 * dir][c]) {
                        moves.push({ row: r + 2 * dir, col: c });
                    }
                }
                // Captures
                [-1, 1].forEach(cd => {
                    if (isValid(r + dir, c + cd) && board[r + dir][c + cd] && board[r + dir][c + cd][0] !== color) {
                        moves.push({ row: r + dir, col: c + cd });
                    }
                });
                // En passant would be added here (omitted for simplicity in this version)
                return moves;
            }
            
            function getRookMoves(r, c, color) {
                return getSlidingMoves(r, c, color, [[-1, 0], [1, 0], [0, -1], [0, 1]]);
            }
            
            function getBishopMoves(r, c, color) {
                return getSlidingMoves(r, c, color, [[-1, -1], [-1, 1], [1, -1], [1, 1]]);
            }

            function getQueenMoves(r, c, color) {
                return getSlidingMoves(r, c, color, [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]);
            }
            
            function getSlidingMoves(r, c, color, directions) {
                const moves = [];
                directions.forEach(([dr, dc]) => {
                    let cr = r + dr, cc = c + dc;
                    while (isValid(cr, cc)) {
                        if (board[cr][cc]) {
                            if (board[cr][cc][0] !== color) moves.push({ row: cr, col: cc });
                            break;
                        }
                        moves.push({ row: cr, col: cc });
                        cr += dr;
                        cc += dc;
                    }
                });
                return moves;
            }

            function getKnightMoves(r, c, color) {
                const moves = [];
                const directions = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                directions.forEach(([dr, dc]) => {
                    const cr = r + dr, cc = c + dc;
                    if (isValid(cr, cc) && (!board[cr][cc] || board[cr][cc][0] !== color)) {
                        moves.push({ row: cr, col: cc });
                    }
                });
                return moves;
            }

            function getKingMoves(r, c, color) {
                const moves = [];
                const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                directions.forEach(([dr, dc]) => {
                    const cr = r + dr, cc = c + dc;
                    if (isValid(cr, cc) && (!board[cr][cc] || board[cr][cc][0] !== color)) {
                        moves.push({ row: cr, col: cc });
                    }
                });
                // Castling would be added here (omitted for simplicity in this version)
                return moves;
            }
            
            function isValid(r, c) {
                return r >= 0 && r < 8 && c >= 0 && c < 8;
            }

            // --- Game Logic: Check, Checkmate, Stalemate ---
            function isKingInCheck(kingColor) {
                const kingPos = kingPositions[kingColor];
                if (!kingPos) return false;
                const opponentColor = kingColor === 'white' ? 'black' : 'white';

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece[0] === opponentColor[0]) {
                            // Get raw moves, ignoring whether they'd put the attacker's own king in check
                            const moves = getRawMoves(r, c, piece);
                            if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            function getRawMoves(row, col, piece) {
                // This is a simplified version of getValidMoves that doesn't check for self-check.
                // It's used to determine if a piece is attacking a square.
                const color = piece[0];
                const type = piece[1];
                switch (type) {
                    case 'P': return getPawnMoves(row, col, color);
                    case 'R': return getRookMoves(row, col, color);
                    case 'N': return getKnightMoves(row, col, color);
                    case 'B': return getBishopMoves(row, col, color);
                    case 'Q': return getQueenMoves(row, col, color);
                    case 'K': return getKingMoves(row, col, color);
                }
                return [];
            }

            function moveLeavesKingInCheck(fromRow, fromCol, toRow, toCol, color) {
                // Simulate the move
                const originalPiece = board[toRow][toCol];
                board[toRow][toCol] = board[fromRow][fromCol];
                board[fromRow][fromCol] = null;
                
                const originalKingPos = kingPositions[color];
                if (board[toRow][toCol] === `${color[0]}K`) {
                    kingPositions[color] = { row: toRow, col: toCol };
                }

                const inCheck = isKingInCheck(color);

                // Revert the move
                board[fromRow][fromCol] = board[toRow][toCol];
                board[toRow][toCol] = originalPiece;
                kingPositions[color] = originalKingPos;
                
                return inCheck;
            }
            
            function hasAnyLegalMoves(color) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece[0] === color[0]) {
                            const moves = getValidMoves(r, c, piece);
                            if (moves.length > 0) return true;
                        }
                    }
                }
                return false;
            }
            
            function checkGameState() {
                const inCheck = isKingInCheck(currentPlayer);
                const hasMoves = hasAnyLegalMoves(currentPlayer);

                if (!hasMoves) {
                    isGameOver = true;
                    if (inCheck) {
                        showGameOverModal(`${currentPlayer === 'white' ? 'Black' : 'White'} wins by Checkmate!`);
                    } else {
                        showGameOverModal("Stalemate! It's a draw.");
                    }
                }
            }

            // --- UI Updates ---
            function updateStatus() {
                let message = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
                if (isKingInCheck(currentPlayer)) {
                    message += ' - Check!';
                }
                statusElement.textContent = message;
            }
            
            function showGameOverModal(message) {
                modalMessage.textContent = message;
                gameOverModal.classList.remove('hidden');
            }

            // --- Event Listeners for Buttons ---
            newGameBtn.addEventListener('click', initGame);
            modalNewGameBtn.addEventListener('click', initGame);

            // --- Start the Game ---
            initGame();
        });
    </script>
</body>
</html>
